Pins  {#ChaPins}
====
\tableofcontents

The Beaglebone hardware contains two header connectors, each with 46
pins. That is 92 pins in total. Some of them have no input / output
capability (such as RESET, GND or power supply lines). But the majority
are either analog or digital lines, free or unfree, all to be controled
by libpruio.

Analog lines always operate as input. In contrast, digital lines can
either operate as input or output. Some digital lines have several
features and need to get configured in the maching mode (pinmuxing)
before usage. Some lines are used to control the boot sequence and
mustn't be connected at boot-time. Others are reserved to be used by
the operating system, but they can get freed by massive
re-configuration of the boot sequence, so that libpruio can control
them. Some header pins are connected to two CPU balls (and both CPU
balls must not be set in contrary output states).

Here's an overview of the Beaglebone Black default configuration (the
Beaglebone White setting is different). libpruio can operate on all
colored pins

![Header pins controllable by libpruio](pins.png)


Analog {#SecAnalog}
======

Analog lines work always as input line. Analog output isn't supported
by the Beaglebone hardware (but can get achieved by a combination of a
PWM output and a hardware filter).

Analog inputs operate in the range of 0 to 1V8. The header pins are
directly connected to the CPU connectors. There's no overvoltage
protection, so in order to avoid hardware damages you mustn't trespass
the maximum voltage range.

The ADC subsystem samples the input with 12 bit resolution. The minimum
input (0V) gets sampled as 0 (zero) and the maximum input (1V8) gets
sampled as 4095.

In addition to the seven analog lines available on the header pins
(AIN-0 to AIN-6), libpruio can also receive samples from the AIN-7
line, which is internal connected to the board power line (3V3) by a
50/50 voltage divider. This may be useful to measure the on board
voltage, in oder to control the power supply.

libpruio offers full control over the ADC subsystem configuration. Up
to 16 ADC steps can get configured to switch the required input line,
specify individual delay values and maybe apply avaraging. The ADC
subsystem supports analog input up to a frequency of 200 kHz. This
works for up to eight steps. The maximum frequency shrinks when

- avaraging of the samples gets applied, or
- more than eight steps are active, or
- delays (open or sample) are required, or
- a clock devider is active (see AdcSet::ADC_CLKDIV).

Here's the strategy to fetch analog input (after calling the
constructor PruIo::PruIo() )

-# configure ADC steps by calling AdcUdt::setStep() (or use default
   configuration generated by the constructor PruIo::PruIo() ).

-# specify the run mode, step mask and bit encoding by calling function
   PruIo::config(). In case of RB or MM mode, also set the number of
   samples (*Samp* > 1) and the measurement frequency (*Tmr*) in this
   call.

-# Only for IO or MM mode (when *Samp* > 1): start the sampling by
   calling either PruIo::rb_start() or PruIo::mm_start().

-# Get the samples in array AdcUdt::Value.

Samples are always scaled as raw data (digits), but can get encoded in
different bit formats. The default encoding is 16 bit. This means the
maximum input of 1V8 gets measured as 65520 (= 4095 * 16).

Find further details on analog lines and the ADC subsystem
configurations in \ArmRef{12}.


Digital {#SecDigital}
=======

Each digital header pin can get configured either in GPIO mode or in
one of up to seven alternative modes, see \ref SecPinConfig for further
information. The matrix of the possible connections is hard-coded in
the CPU logic. Find the subset of the Beaglebone headers described in
the \BbbRef{7}. Or find the complete description in the CPU
dokumentation \MpuRef{2.2} .

Before a digital header pin gets used, libpruio checks its mode. When
the current setting matches the required feature, libpruio just
continues and operates the pin. Otherwise it tries to change the
pinmuxing appropriately, first. This needs the libpruio-00A0.dtbo
device tree overlay loaded and the program has to be executed with
admin privileges for write access to the pinmuxing folders in

~~~{.sh}
/sys/devices/ocp.?/pruio-??.??
~~~

The overlay contains pre-defined modes for a certain set of CPU balls.
By default the overlay claims the free pins on the BBB headers. Those
are the orange and blue pins in the above image. When you're using a
Beaglebone White or when you free further pins on the BBB, ie. by
disabling HDMI or other features on the board, you can easily create an
universal overlay with adapted pin claiming by using the tool
dts_universal.bas.

If you don't want to execute the program under admin privileges, you've
to ensure that all used digital header pins are in the appropriate mode
before you start the program (so that the initial checks succeed). This
can get achieved by loading a customized overlay. In contrast to the
universal overlay, the customized contains only one configuration for
the used header pins and libpruio cannot change the mode at run-time.
You can easily create a customized overlay with fixed pinmuxing by
using the tool dts_custom.bas.

In any case, all digital lines operates in the range of 0 to 3V3. An
input pin returns low in the range of 0 to 0V8 and high in the range of
1V8 to 3V3. In the range inbetween the state is undefined. The maximum
current on an output pin shouldn't exceed 6 mA.

| Mode   |   LOW    |    HIGH    | Notice                    |
| -----: | :------: | :--------: | :------------------------ |
| output | 0        | 3V3        | max. 6 mA                 |
|  input | 0 to 0V8 | 1V8 to 3V3 | undefined from 0V8 to 1V8 |

Two of the Beaglebone header pins are connected to multiple CPU balls.
Those are P9_41 and P9_42. When changing the pinmuxing of any of the
related CPU balls, it must be ensured that the second CPU ball doesn't
operate in a contrary output state. Therefor the universal device tree
overlay libpruio-00A0.dtbo (and all overlays generated by the tools
dts_custom.bas and dts_universal.bas) always configures two CPU balls
for those pins at once. First, the unused CPU ball gets set in a GPIO
input mode (without resistor) and then the other ball gets set
accordingly.

Some pins are used to control the boot sequence and mustn't be
connected at boot-time.


GPIO {#SubSecGpio}
----

GPIO stands for General Purpose Input or Output. In output mode the
program can switch any connected hardware on or off. In input mode the
program can detect the state of any connected hardware. libpruio can
configure and use any digital header pin in one of the following five
GPIO modes. (Therefor the universal device tree overlay
libpruio-00A0.dtbo has to be loaded and the program has to be executed
with admin privileges.) Find details on GPIO hardware in \ArmRef{25}.

| PinMuxing Enumerator | Function                         | GpioUdt::Value() |
| -------------------: | :------------------------------: | :--------------- |
| \ref PRUIO_GPIO_OUT0 | output pin low (no resistor)     | 0                |
| \ref PRUIO_GPIO_OUT1 | output pin high (no resistor)    | 1                |
| \ref PRUIO_GPIO_IN   | input pin with no resistor       | undefined        |
| \ref PRUIO_GPIO_IN_0 | input pin with pulldown resistor | 0                |
| \ref PRUIO_GPIO_IN_1 | input pin with pullup resistor   | 1                |

An input pin can get configured with pullup or pulldown resistor, or
none of them. Those resistors (about 10 k) are incorporated in the CPU.
In contrast, libpruio configures an output pin always with no CPU
resistor connection (to minimize power consumption). So the first two
modes (PRUIO_GPIO_OUT0 and PRUIO_GPIO_OUT1) use the same pinmuxing.

Those modes are predefined in the universal overlay libpruio-00A0.dtbo for each claimed header pin.


 and the initial state must
get specified at configuration time.

Here're the GPIO pin configurations supported by the universal device
tree overlay libpruio-00A0.dtbo

In some cases it may be reasonable to use an output pin with pullup
resistor, which isn't supported by default. This either needs pinmuxing
by a customized device tree overlay or it can be achieved by adding
this new mode to the universal device tree overlay libpruio-00A0.dtbo.


PWM {#SubSecPwm}
---

PWM stands for Pulse Width Modulated output. So it means generating a
digital signal with a given frequency and duty cycle. Usualy PWM is
used to control actuators, ie. to control the speed of a DC engine.

PWM is available on a subset of header pins. A PWM pin is configured as
an output pin without resistor connection. This pin gets auto-set to
high or low state, depending on a counter running on a certain clock
rate. When the counter matches specified values, the state of the
output toggles. Since PWM output can get generated by different
subsystems (and libpruio supports many of them), the resolution and the
frequency range vary between the pins.

| Pin   | Subsystem      | Frequency Range        |
| ----- | :------------: | :--------------------- |
| P8_07 | TIMER-4        | 0,000007629 to 50e6 Hz |
| P8_13 | PWMSS-2, PWM B | 0.42 to 50e6 Hz        |
| P8_19 | PWMSS-2, PWM A | 0.42 to 50e6 Hz        |
| P8_34 | PWMSS-1, PWM B | 0.42 to 50e6 Hz        |
| P8_36 | PWMSS-1, PWM A | 0.42 to 50e6 Hz        |
| P8_45 | PWMSS-2, PWM B | 0.42 to 50e6 Hz        |
| P8_46 | PWMSS-2, PWM A | 0.42 to 50e6 Hz        |
| P9_14 | PWMSS-1, PWM A | 0.42 to 50e6 Hz        |
| P9_16 | PWMSS-1, PWM B | 0.42 to 50e6 Hz        |
| P9_21 | PWMSS-0, PWM B | 0.42 to 50e6 Hz        |
| P9_22 | PWMSS-0, PWM A | 0.42 to 50e6 Hz        |
| P9_29 | PWMSS-0, PWM B | 0.42 to 50e6 Hz        |
| P9_31 | PWMSS-0, PWM A | 0.42 to 50e6 Hz        |
| P9_28 | PWMSS-2, CAP   | 0.0233 to 50e6 Hz      |
| P9_42 | PWMSS-0, CAP   | 0.0233 to 50e6 Hz      |

The TIMER and PWMSS-CAP subsystems use a 32 bit counter and generate a
single pulse train. The signal goes high at the beginning of the period
and low when the compare value is reached. In the TIMER subsystems the
counter clock can get pre-scaled, so very long periods (low
frequencies) are possible. The maximum is ??? days.

In contrast the PWMSS-PWM subsystems use a 16 bit counter with 17 bit
duty resolution in up-down mode. The frequency range can get extended
by a clock pre-scaler. libpruio auto-configures the mode and the
pre-scaler. For high frequencies (low counter periods) the counter runs
in up-count mode (16 bit resolution). For frequencies below 1526 Hz (=
100e6 / 65536) the counter runs in up-down mode (17 bit duty
resolution, 16 bit frequency resolution). This up-down mode can be
forced for high frequencies also by masking the subsystems bit in
member variable PwmMod::ForceUpDown to 1.

A PWMSS-PWM subsystem handles two outputs at the same frequency. Two
Action Qualifiers are used to set the states of the outputs A and B in
case of six different events, see \ArmRef{5.2.4.3} for details. By
default libpruio configures the Action Qualifiers to set both outputs to
high state at the beginning of a period and switch to low state when
the counter matches the duty value. The default configuration can get
overriden in array PwmMod::AcCtl. This three dimensional array contains
the configurations for the Action Qualifiers.

| Index | Value | Description                                                                    |
| :---: | :---: | :----------------------------------------------------------------------------- |
|   1   |  0,1  | Output (0 = A, 1 = B)                                                          |
|   2   |  0-2  | Subsystem                                                                      |
|   3   |  0-2  | Usecase (0 = up count, 1 = up count up-down mode, 2 = down count up-down mode) |

Additionally the PWMSS-PWM modules can get synchronized. ???

The output gets specified by calling function PwmMod::setVakue(). Since
the output frequency may vary from the specified parameters due to
resolution issues, the real values can get computed by calling function
PwmMod::Value().


CAP {#SubSecCap}
---

CAP stands for Capture and Analyse a digital Pulse train. So it means
measuring the frequency and the duty cycle of a digital signal input.
It's a kind of reverse PWM. Usualy CAP is used to read sensor inputs,
ie. from a speed sensor.

CAP is available on a subset of header pins. The specified pin gets
configured as input with pulldown resistor. A counter is running on a
certain clock rate. Each transition of the input triggers the capture
of the counter value. The frequency gets measured as the difference
between two positive transitions (a period). The duty cycle gets
measured as the ratio between a period and the on-time of the signal. A
positive transition resets the couter. Since CAP input can get analysed
by different subsystems (and libpruio support some of them), the
frequency range vary between the pins.

| Pin   | Subsystem      | Frequency Range        |
| ----- | :------------: | :--------------------- |
| P8_07 | TIMER-4        | 0,000007629 to 50e6 Hz |
| P9_28 | PWMSS-2, CAP   | 0.0233 to 50e6 Hz      |
| P9_42 | PWMSS-0, CAP   | 0.0233 to 50e6 Hz      |

The measurement results get available by calling function
CapMod::Value(). Before, you have to configure the pin for CAP input by
calling function CapMod::config() once.


QEP {#SubSecQep}
---

QEP stands for Quadrature Encoder Pulse measurement. So it means
measuring the position and the speed of a quadrature encoder. Encoders
for rotary (ie. for an electrical drive) and linear (ie. for a printer
head) movement are supported.

QEP is available on a subset of the header pins. Each of the three
PWMSS subsystems contains a QEP module. (The QEP module of PWMSS-2 can
get connected on two sets of to the header pins.)

The module can operate in different modes, and depending on the mode it
operates on a different set of input signals (header pins). Function
QepMod::config() is used to specify the operational mode of the module.
It configures one or more header pins, depending on the first parameter
*Ball*. And depending on the mode (and the number of input pins),
either

- speed, or
- speed, direction and position

information is available when calling function QepMod::Value(). The
accuracy of the position information can get improved by using an index
signal that resets the position counter.

| Ball  | Type    | PWMSS | Speed | Direction | Position | Index | Further Pins |
| ----- | :-----: | :---: | :---: | :-------: | :------: | :---: | :----------- |
| P8_12 | A input |   2   |   X   |     -     |     -    |   -   |              |
| P8_11 | B input |   2   |   X   |     X     |     X    |   -   | P8_12        |
| P8_16 | I input |   2   |   X   |     X     |     X    |   X   | P8_11, P8_12 |
| P8_35 | A input |   1   |   X   |     -     |     -    |   -   |              |
| P8_33 | B input |   1   |   X   |     X     |     X    |   -   | P8_35        |
| P8_31 | I input |   1   |   X   |     X     |     X    |   X   | P8_35, P8_33 |
| P8_41 | A input |   2   |   X   |     -     |     -    |   -   |              |
| P8_42 | B input |   2   |   X   |     X     |     X    |   -   | P8_41        |
| P8_39 | I input |   2   |   X   |     X     |     X    |   X   | P8_41, P8_42 |
| P9_42 | A input |   0   |   X   |     -     |     -    |   -   |              |
| P9_27 | B input |   0   |   X   |     X     |     X    |   -   | P9_42        |
| P9_41 | I input |   0   |   X   |     X     |     X    |   X   | P9_42, P9_27 |

Direction information is derived from two different signals that "look"
at the sensor lines with a mechanical shift of 1 / 4 of the pitch. So
to get direction information at least an B input (or an I input) needs
to get specified as *Ball* parameter to the function QepMod::config().

The speed is defined as the rate of change of position with respect to
time v = &Delta;x / &Delta;T. The QEP modules Capture Unit works at a
certain frequency, specified by parameter *VHz* in the call to function
QepMod::config(). At this frequency the current position and the time
between the last transitions get stored in the array PwmSS::Raw.
Function QepMod::Value() uses these data to compute the speed. By
default speed values are scaled in transitions per second. Ie. for a
rotary sensor turning at 1 revolution per second you'll get twice the
number of lines for an A input and four times the number of lines for a
B or I input.

For low speed values transitions period time is used in equation v = n
/ &Delta;T, where n is the number of transitions counted (n = 2 for A
input, n = 4 for B or I input). The higher the speed value, the smaller
the speed resolution. So in contrast, high speed values get computed by
counting the number of input transitions in the given period of time
(T), using equation v = &Delta;x / T. libpruio auto-switches between
both equations and auto-computes the optimal speed value for switching
(array QepMod::Prd), in order to get maximum speed resolution.

The speed limits are depending on the hardware in use. Linear sensors
don't have an upper speed limit, unless the counter clock rate doesn't
get exceeded (100e6 Hz). But in case of a rotary sensor the maximum
speed is limited by the number of sensor lines per revolution. When the
sensor turns more than one revolution in the measurement period
(parameter *VHz*) the number of transitions (&Delta;x) will be
incorrect. So for rotary encoders you've to make sure that the
measurement frequency is higher than the maximum sensor frequency, ie.
*VHz* = 25 limits the shaft speed to 1500 rpm (= 25 [1/s] * 60
[s/min]). An alternative approach is to specify a multiple of the
sensor lines as parameter *PMax* and correct the position information
accordingly. Parameter *Scale* can be used to apply a custom scaling
factor to speed computations.

The minimum speed is limited by the measurement frequency (*VHz*). When
no transition period (2 transitions for A input, 4 transitions for B or
I input) occurs in the measurement time (*VHz*), the speed gets
computed to zero. That's also the case when the direction changes
during the measurement period. By default libpruio doesn't count each
transition, because time measurement in this case requires high
accuracy of the sensor mechanics. If either the duty cycle of a signal
is not exactly 50 % or the phase shift between A and B signals is not
exactly 1 / 4 (90 &deg;), the computed speed values will change
erratic. Since most sensors don't fulfill those requirements, libpruio
measures frequency on just one transition of a single signal. This
means at least two (in case of A input) or four position counts (in
case of B and I input) are necessary to measure a non-zero speed value.

\note A direction change during the time period always results in
      zero-speed computation.

Position information is computed by counting the transitions of the
input signals considering the direction information (A and B inputs are
necessary). In case of just one input the position counter runs in
upwart direction.

An index signal (I input) can be used to reset the counter. By default
the counter is set to zero on the positive transition of the index
signal when counting in upward direction. And the counter is set to
value *PMax* on the negative transition of the index signal when
counting in downward direction.

The measurement results get available by calling function
QepMod::Value(). Before, you have to configure the pin(s) for QEP input
by calling function QepMod::config() once.
