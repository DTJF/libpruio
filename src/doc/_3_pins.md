Pins  {#ChaPins}
====
\tableofcontents

The Beaglebone hardware contains two header connectors, each with 46
pins. That is 92 pins in total. Most of them have input / output
capabilities, while just a few are related to other features (such as
RESET, GND or power supply lines). Input / output pins are either
analog or digital lines, free or unfree (used by the system in default
configuration). All can get controled by \Proj.

Analog lines always operate as input. In contrast, digital lines can
either operate as input or output. Some digital lines have several
features at the same pin and need to get configured to the matching
mode before usage (pinmuxing). In addition, some lines are used to
control the boot sequence and mustn't be connected at boot-time. Others
are reserved to be used by the system (e. g. for HDMI or MCASP), but
they can get freed by massive re-configuration of the boot sequence, so
that you can use them. Some header pins are connected to two CPU balls
(and both CPU balls must not be set in contrary output states, in order
to avoid hardware damages).

Here's an overview of the Beaglebone Black default configuration (the
Beaglebone White setting is different). \Proj can operate on all
colored pins

![Header pins controllable by libpruio](pins.png)


This section explains the different functions the header pins can work
in and gives detailed information about the limits.


# Analog  {#SecAnalog}

Analog lines work always as input line. Analog output isn't supported
by the Beaglebone hardware (but can get achieved by a combination of a
PWM output and a hardware filter).

Analog inputs operate in the range of 0 to 1V8. The header pins are
directly connected to the CPU connectors. There's no overvoltage
protection, so in order to avoid hardware damages you mustn't trespass
the maximum voltage range.

In addition to the seven analog lines available on the header pins
(see table below), \Proj can also receive samples from the AIN-7
line, which is internal connected to the board power line (3V3) by a
50/50 voltage divider. This may be useful to measure the on board
voltage, in oder to control the power supply.

| Ball  | Description                            |
| ----- | :------------------------------------- |
| P9_39 | AIN-0 (default configuration in step 1 |
| P9_40 | AIN-1 (default configuration in step 2 |
| P9_37 | AIN-2 (default configuration in step 3 |
| P9_38 | AIN-3 (default configuration in step 4 |
| P9_33 | AIN-4 (default configuration in step 5 |
| P9_36 | AIN-5 (default configuration in step 6 |
| P9_35 | AIN-6 (default configuration in step 7 |

The ADC subsystem samples the input with 12 bit resolution. The minimum
input (0V) gets sampled as 0 (zero) and the maximum input (1V8) gets
sampled as 4095. In order to make this raw data comparable with other
ADC input, \Proj can encode to different bit formats. The default
encoding is 16 bit. This means the maximum input of 1V8 gets measured
as 65520 (= 4095 * 16).

\Proj offers full control over the ADC subsystem configuration. Up to
16 ADC steps can get configured to switch the required input line,
specify individual delay values and maybe apply avaraging. The ADC
subsystem supports analog input up to a frequency of 200 kHz. This
works for up to eight steps. The maximum frequency shrinks when

- avaraging of the samples gets applied, or
- more than eight steps are active, or
- delays (open or sample) are required, or
- a clock devider is active (see AdcSet::ADC_CLKDIV).

Here's the strategy to fetch analog input (after calling the
constructor PruIo::PruIo() )

-# configure ADC steps by calling AdcUdt::setStep() (or use default
   configuration generated by the constructor PruIo::PruIo() ).

-# specify the run mode, step mask and bit encoding by calling function
   PruIo::config(). In case of RB or MM mode, also set the number of
   samples (*Samp* > 1) and the measurement frequency (*Tmr*) in this
   call.

-# Only for RB or MM mode (when *Samp* > 1): start the sampling by
   calling either PruIo::rb_start() or PruIo::mm_start().

-# Get the samples in array AdcUdt::Value.

Find further details on analog lines and the ADC subsystem
configurations in \ArmRef{12}. Find example code in io_input.bas,
oszi.bas, rb_file.bas, rb_oszi.bas and trigger.bas.


# Digital  {#SecDigital}

Each digital header pin can get configured either in GPIO mode or in
one of up to seven alternative modes. The matrix of the possible
connections is hard-coded in the CPU logic. Find the subset of the
Beaglebone headers described in the \BbbRef{7}. Or find the complete
description in the CPU documentation \MpuRef{2.2} .

Before a digital header pin gets used, \Proj checks its mode. When the
current setting matches the required feature, \Proj just continues and
operates the pin. Otherwise it tries to change the pinmuxing
appropriately, first. This needs the libpruio-00A0.dtbo device tree
overlay loaded, and the program has to be executed with admin
privileges for write access to the pinmuxing folders in

- `/sys/devices/ocp.?/pruio-??.*` (kernel 3.8)
- `/sys/devices/platform/ocp/ocp:pruio-??` (kernel >3.8)

The overlay contains pre-defined modes for a certain set of CPU balls.
By default the overlay claims all the free pins on the BBB headers.
Those are the orange and blue pins in the above image. When you're
using a Beaglebone White or Green, or when you free further pins on the
BBB, ie. by disabling HDMI or other features on the board, you can
create an universal overlay with adapted pin claiming. This can get
easily done by using the tool dts_universal.bas.

If you don't want to execute the program under admin privileges, you've
to ensure that all used digital header pins are in the appropriate mode
before you start the program (so that the initial checks succeed). This
can get achieved by loading a customized overlay. In contrast to the
universal overlay, the customized contains only one configuration for
each used header pin and \Proj cannot change the mode at run-time. You
can easily create a customized overlay with fixed pinmuxing by using
the tool dts_custom.bas.

In any case, all digital lines operates in the range of 0 to 3V3. An
input pin returns low in the range of 0 to 0V8 and high in the range of
1V8 to 3V3. In the range inbetween the state is undefined. The maximum
current on an output pin shouldn't exceed 6 mA.

| Mode   |   LOW    |    HIGH    | Notice                    |
| -----: | :------: | :--------: | :------------------------ |
| output | 0        | 3V3        | max. 6 mA                 |
|  input | 0 to 0V8 | 1V8 to 3V3 | undefined from 0V8 to 1V8 |

Two of the Beaglebone header pins are connected to multiple CPU balls.
Those are P9_41 and P9_42. When changing the pinmuxing of any of the
related CPU balls, it must be ensured that the second CPU ball doesn't
operate in a contrary output state. Therefor the universal device tree
overlay libpruio-00A0.dtbo (and all overlays generated by the tools
dts_custom.bas and dts_universal.bas) always configures two CPU balls
for those pins at once. First, the unused CPU ball gets set in a GPIO
input mode (without resistor) and then the other ball gets set
accordingly.

Some pins are used to control the boot sequence and mustn't be
connected at boot-time.

Depending on the pin mode the pin can act either as input or output
pin. Here's the strategy to fetch digital input (after calling the
constructor PruIo::PruIo() )

- configure the pin by the related function (GpioUdt::config(),
  CapUdt::config() or QepUdt::config() ).

- start the main loop by calling PruIo::config()

- read the current pin state by calling the related function
  (GpioUdt::Value(), CapUdt::Value() or QepUdt::Value() ).

And here's the strategy to set digital output (after calling the
constructor PruIo::PruIo() )

- start the main loop by calling PruIo::config()

- set the required pin state by calling the related function
  (GpioUdt::setValue() or PwmUdt::setValue() ).


## GPIO  {#sSecGpio}

GPIO stands for General Purpose Input or Output. In output mode the
program can switch any connected hardware on or off. In input mode the
program can detect the state of any connected hardware. \Proj can
configure and use any digital header pin in one of the following five
GPIO modes. (Therefor the universal device tree overlay
libpruio-00A0.dtbo has to be loaded and the program has to be executed
with admin privileges.) Find details on GPIO hardware in \ArmRef{25}.

| PinMuxing Enumerator | Function                         | GpioUdt::Value() |
| -------------------: | :------------------------------: | :--------------- |
| \ref PRUIO_GPIO_OUT0 | output pin low (no resistor)     | 0                |
| \ref PRUIO_GPIO_OUT1 | output pin high (no resistor)    | 1                |
| \ref PRUIO_GPIO_IN   | input pin with no resistor       | undefined        |
| \ref PRUIO_GPIO_IN_0 | input pin with pulldown resistor | 0                |
| \ref PRUIO_GPIO_IN_1 | input pin with pullup resistor   | 1                |

An input pin can get configured with pullup or pulldown resistor, or
none of them. Those resistors (about 10 k) are incorporated in the CPU.
In contrast, output pins get always configured with no CPU resistor
connection by \Proj (to minimize power consumption). So the first two
modes (PRUIO_GPIO_OUT0 and PRUIO_GPIO_OUT1) use the same pinmuxing.
Those modes are predefined in the universal overlay libpruio-00A0.dtbo
for each claimed header pin.

In order to set a GPIO output just set its state by calling function
Gpio::setValue() (after calling the constructor PruIo::PruIo() ). When
you do this after the call to PruIo::config(), the state will change
immediately. Otherwise it changes after the PruIo::config() call.

In order to get a GPIO input configure the pin first by
calling function GpioUdt::config() (after calling the constructor
PruIo::PruIo() and before the call to PruIo::config()). Then check its
state by calling function GpioUdt::Value() (after the call to
PruIo::config() ).

Find example code in button.bas (input) or sos.bas and stepper.bas
(output).


## TIMER  {#sSecTimer}

A TIMER output sends a pulse to a header pin. First, it waits a certain
time and then toggles the state for a certain time. After that sequence
the pin toggles back and the sequence starts again. In contrast, when
PRUIO_TIMER_ONE bit is set, the sequence stops after it returns to the
initial state (only available for TIMER pins). By default the signal
starts at low state and generates a high pulse. In contrast, when bit
PRUIO_TIMER_INVERS is set, the signal starts at high state and
generates a low pulse.

The TIMER feature is available on a subset of header pins. A TIMER pin
is configured as an output pin without resistor connection. This pin
gets auto-set to high or low state, depending on a counter running on a
certain clock rate. When the counter matches specified values, the
state of the output toggles. Since TIMER output can get generated by
different subsystems (and \Proj supports some of them), the resolution
is 32 bit and the duration range in [s] vary between the pins.

| Pin   | Subsystem       | Max Dur |   Min Dur   | Notice            |
| ----- | :-------------: | :-----: | :---------: | :---------------- |
| P8_07 | TIMER-4         | 45812   | 0,000000167 | free              |
| P8_09 | TIMER-5         | 45812   | 0,000000167 | free              |
| P8_10 | TIMER-6         | 45812   | 0,000000167 | free              |
| P8_08 | TIMER-7         | 45812   | 0,000000167 | free              |
| P9_28 | PWMSS-2, CAP    | 42,94   | 0,00000002  | MCASP0            |
| P9_42 | PWMSS-0, CAP    | 42,94   | 0,00000002  | free (double pin) |
| JT_05 | PWMSS-1, CAP    | 42,94   | 0,00000002  | JTag (UART0_TXD)  |

The output gets specified by calling function TimerUdt::setValue().
Since the output timing may vary from the specified parameters due to
resolution issues, the real values can get computed by calling function
TimerUdt::Value().


## PWM  {#sSecPwm}

PWM stands for Pulse Width Modulated output. So it means generating a
digital signal with a given frequency and duty cycle. Usualy PWM is
used to control actuators, ie. to control the speed of a DC engine.

PWM is available on a subset of header pins. A PWM pin is configured as
an output pin without resistor connection. This pin gets auto-set to
high or low state, depending on a counter running on a certain clock
rate. When the counter matches specified values, the state of the
output toggles. Since PWM output can get generated by different
subsystems (and \Proj supports many of them), the resolution and the
frequency range vary between the pins.

| Pin   | Subsystem       | Frequency Range        | Notice            |
| ----- | :-------------: | ---------------------: | :---------------- |
| P8_07 | TIMER-4         | 0.000010914 to 6e6 Hz  | free              |
| P8_09 | TIMER-5         | 0.000010914 to 6e6 Hz  | free              |
| P8_10 | TIMER-6         | 0.000010914 to 6e6 Hz  | free              |
| P8_08 | TIMER-7         | 0.000010914 to 6e6 Hz  | free              |
| P8_13 | PWMSS-2, PWM B  | 0.42 to 50e6 Hz        | free              |
| P8_19 | PWMSS-2, PWM A  | 0.42 to 50e6 Hz        | free              |
| P9_14 | PWMSS-1, PWM A  | 0.42 to 50e6 Hz        | free              |
| P9_16 | PWMSS-1, PWM B  | 0.42 to 50e6 Hz        | free              |
| P9_21 | PWMSS-0, PWM B  | 0.42 to 50e6 Hz        | free              |
| P9_22 | PWMSS-0, PWM A  | 0.42 to 50e6 Hz        | free              |
| P8_34 | PWMSS-1, PWM B  | 0.42 to 50e6 Hz        | HDMI              |
| P8_36 | PWMSS-1, PWM A  | 0.42 to 50e6 Hz        | HDMI              |
| P8_45 | PWMSS-2, PWM B  | 0.42 to 50e6 Hz        | HDMI              |
| P8_46 | PWMSS-2, PWM A  | 0.42 to 50e6 Hz        | HDMI              |
| P9_29 | PWMSS-0, PWM B  | 0.42 to 50e6 Hz        | MCASP0            |
| P9_31 | PWMSS-0, PWM A  | 0.42 to 50e6 Hz        | MCASP0            |
| P9_28 | PWMSS-2, CAP    | 0.0233 to 50e6 Hz      | MCASP0            |
| P9_42 | PWMSS-0, CAP    | 0.0233 to 50e6 Hz      | free (double pin) |
| JT_05 | PWMSS-1, CAP    | 0.0233 to 50e6 Hz      | JTag (UART0_TXD)  |

The TIMER and PWMSS-CAP subsystems use a 32 bit counter and generate a
single pulse train. The signal goes high at the beginning of the period
and low when the compare value is reached. In the TIMER subsystems the
counter clock can get pre-scaled, so very long periods (low
frequencies) are possible. The maximum is ??? days.

In contrast the PWMSS-PWM subsystems use a 16 bit counter with 17 bit
duty resolution in up-down mode. The frequency range can get extended
by a clock pre-scaler. \Proj auto-configures the mode and the
pre-scaler. For high frequencies (low counter periods) the counter runs
in up-count mode (16 bit resolution). For frequencies below 1526 Hz (=
100e6 / 65536) the counter runs in up-down mode (17 bit duty
resolution, 16 bit frequency resolution). This up-down mode can be
forced for high frequencies also by masking the subsystems bit in
member variable PwmMod::ForceUpDown to 1.

A PWMSS-PWM subsystem handles two outputs at the same frequency. Two
Action Qualifiers are used to set the states of the outputs A and B in
case of six different events, see \ArmRef{5.2.4.3} for details. By
default \Proj configures the Action Qualifiers to set both outputs to
high state at the beginning of a period and switch to low state when
the counter matches the duty value. The default configuration can get
overriden in array PwmMod::AcCtl. This three dimensional array contains
the configurations for the Action Qualifiers.

| Index | Value | Description                                                                    |
| :---: | :---: | :----------------------------------------------------------------------------- |
|   1   |  0,1  | Output (0 = A, 1 = B)                                                          |
|   2   |  0-2  | Subsystem                                                                      |
|   3   |  0-2  | Usecase (0 = up count, 1 = up count up-down mode, 2 = down count up-down mode) |

Additionally the PWMSS-PWM modules can get synchronized. ???

The output gets specified by calling function PwmMod::setValue(). Since
the output frequency may vary from the specified parameters due to
resolution issues, the real values can get computed by calling function
PwmMod::Value().

Find example code in pwm_adc.bas or pwm_cap.bas.


## CAP  {#sSecCap}

CAP stands for Capture and Analyse a digital Pulse train. So it means
measuring the frequency and the duty cycle of a digital signal input.
It's a kind of reverse PWM. Usualy CAP is used to read sensor inputs,
ie. from a speed sensor.

CAP is available on a subset of header pins. The specified pin gets
configured as input with pulldown resistor. A counter is running on a
certain clock rate. Each transition of the input triggers the capture
of the counter value. The frequency gets measured as the difference
between two positive transitions (a period). The duty cycle gets
measured as the ratio between a period and the on-time of the signal. A
positive transition resets the couter. Since CAP input can get analysed
by different subsystems (and \Proj support some of them), the frequency
range vary between the pins.

| Pin   |   Subsystem    | Frequency Range        | Notice            |
| ----- | :------------: | :--------------------- | :---------------- |
| P9_28 | PWMSS-2, CAP   | 0.0233 to 50e6 Hz      | MCASP0            |
| P9_42 | PWMSS-0, CAP   | 0.0233 to 50e6 Hz      | free (double pin) |
| JT_04 | PWMSS-2, CAP   | 0.0233 to 50e6 Hz      | JTag (UART0_RXD)  |

The measurement results get available by calling function
CapMod::Value(). Before, you have to configure the pin for CAP input by
calling function CapMod::config() once.

Find example code in pwm_cap.bas.


## QEP  {#sSecQep}

QEP stands for Quadrature Encoder Pulse measurement. So it means
measuring the position and the speed of a quadrature encoder. Encoders
for rotary (ie. for an electrical drive) and linear (ie. for a printer
head) movement are supported.

QEP is available on a subset of the header pins. Each of the three
PWMSS subsystems contains a QEP module. (The QEP module of PWMSS-2 can
get connected on two sets of to the header pins.)

The module can operate in different modes, and depending on the mode it
operates on a different set of input signals (header pins). Function
QepMod::config() is used to specify the operational mode of the module.
It configures one or more header pins, depending on the first parameter
*Ball*. And depending on the mode (and the number of input pins),
either

- speed, or
- speed, direction and position

information is available when calling function QepMod::Value(). The
accuracy of the position information can get improved by using an index
signal that resets the position counter.

| Ball  | Type    | Subsystem | Speed | Direction | Position | Index | Further Pins | Notice            |
| ----- | :-----: | :-------: | :---: | :-------: | :------: | :---: | :----------- | :---------------- |
| P8_12 | A input |  PWMSS-2  |   X   |     -     |     -    |   -   |              | free              |
| P8_11 | B input |  PWMSS-2  |   X   |     X     |     X    |   -   | P8_12        | free              |
| P8_16 | I input |  PWMSS-2  |   X   |     X     |     X    |   X   | P8_11, P8_12 | free              |
| P8_35 | A input |  PWMSS-1  |   X   |     -     |     -    |   -   |              | HDMI              |
| P8_33 | B input |  PWMSS-1  |   X   |     X     |     X    |   -   | P8_35        | HDMI              |
| P8_31 | I input |  PWMSS-1  |   X   |     X     |     X    |   X   | P8_35, P8_33 | HDMI              |
| P8_41 | A input |  PWMSS-2  |   X   |     -     |     -    |   -   |              | HDMI              |
| P8_42 | B input |  PWMSS-2  |   X   |     X     |     X    |   -   | P8_41        | HDMI              |
| P8_39 | I input |  PWMSS-2  |   X   |     X     |     X    |   X   | P8_41, P8_42 | HDMI              |
| P9_42 | A input |  PWMSS-0  |   X   |     -     |     -    |   -   |              | free (double pin) |
| P9_27 | B input |  PWMSS-0  |   X   |     X     |     X    |   -   | P9_42        | free              |
| P9_41 | I input |  PWMSS-0  |   X   |     X     |     X    |   X   | P9_42, P9_27 | free (double pin) |

Direction information is derived from two different signals that "look"
at the sensor lines with a mechanical shift of 1 / 4 of the pitch. So
to get direction information at least an B input (or an I input) needs
to get specified as *Ball* parameter to the function QepMod::config().

The speed is defined as the rate of change of position with respect to
time v = &Delta;x / &Delta;T. The QEP modules Capture Unit works at a
certain frequency, specified by parameter *VHz* in the call to function
QepMod::config(). At this frequency the current position and the time
between the last transitions get stored in the array PwmSS::Raw.
Function QepMod::Value() uses these data to compute the speed. By
default speed values are scaled in transitions per second. Ie. for a
rotary sensor turning at 1 revolution per second you'll get twice the
number of lines for an A input and four times the number of lines for a
B or I input.

For low speed values transitions period time is used in equation v = n
/ &Delta;T, where n is the number of transitions counted (n = 2 for A
input, n = 4 for B or I input). The higher the speed value, the smaller
the speed resolution. So in contrast, high speed values get computed by
counting the number of input transitions in the given period of time
(T), using equation v = &Delta;x / T. \Proj auto-switches between both
equations and auto-computes the optimal speed value for switching
(array QepMod::Prd), in order to get maximum speed resolution.

The speed limits are depending on the hardware in use. Linear sensors
don't have an upper speed limit, unless the counter clock rate doesn't
get exceeded (100e6 Hz). But in case of a rotary sensor the maximum
speed is limited by the number of sensor lines per revolution. When the
sensor turns more than one revolution in the measurement period
(parameter *VHz*) the number of transitions (&Delta;x) will be
incorrect. So for rotary encoders you've to make sure that the
measurement frequency is higher than the maximum sensor frequency, ie.
*VHz* = 25 limits the shaft speed to 1500 rpm (= 25 [1/s] * 60
[s/min]). An alternative approach is to specify a multiple of the
sensor lines as parameter *PMax* and correct the position information
accordingly. Parameter *Scale* can be used to apply a custom scaling
factor to speed computations.

The minimum speed is limited by the measurement frequency (*VHz*). When
no transition period (2 transitions for A input, 4 transitions for B or
I input) occurs in the measurement time (*VHz*), the speed gets
computed to zero. That's also the case when the direction changes
during the measurement period. By default \Proj doesn't count each
transition, because time measurement in this case requires high
accuracy of the sensor mechanics. If either the duty cycle of a signal
is not exactly 50 % or the phase shift between A and B signals is not
exactly 1 / 4 (90 &deg;), the computed speed values will change
erratic. Since most sensors don't fulfill those requirements, \Proj
measures frequency on just one transition of a single signal. This
means at least two (in case of A input) or four position counts (in
case of B and I input) are necessary to measure a non-zero speed value.

\note A direction change during the time period always results in
      zero-speed computation.

Position information is computed by counting the transitions of the
input signals considering the direction information (A and B inputs are
necessary). In case of just one input the position counter runs in
upwart direction.

An index signal (I input) can be used to reset the counter. By default
the counter is set to zero on the positive transition of the index
signal when counting in upward direction. And the counter is set to
value *PMax* on the negative transition of the index signal when
counting in downward direction.

The measurement results get available by calling function
QepMod::Value(). Before, you have to configure the pin(s) for QEP input
by calling function QepMod::config() once.

Find example code in qep.bas.


# Pinmuxing  {#SecPinmuxing}

This section describes how to set a header pin in the desired mode. At
startup (= POR = Power On Reset) the operating system sets all pins in
a save mode. Execute example [analyse.bas](sSecExaAnalyse) to see a
list of the default header pin configuration.

When you set up a header pin for use with \Proj, the pin mode gets
checked first. When it matches the desired feature, the pin operation
gets done immediately. Otherwise, if the default configuration doesn't
match the desired function, \Proj tries to adapt the pin mode first.
Therefor it needs pinmuxing capability, ie. by loading the universal
overlay. ???


## Loading an Overlay  {#sSecLoadOverlay}

## Creating an Overlay  {#sSecCreateOverlay}
